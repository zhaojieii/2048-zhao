<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048 - æµç•…ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5e6e8;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            color: #5a427d;
            background-image: radial-gradient(circle at top right, #ffd6e0, #e7c6ff);
            overflow: hidden;
            transition: background-image 1s ease;
        }

        .bg-level-1 {
            background-image: radial-gradient(circle at top right, #ffd6e0, #e7c6ff);
        }

        .bg-level-2 {
            background-image: radial-gradient(circle at top right, #ffc2d1, #d0bdff);
        }

        .bg-level-3 {
            background-image: radial-gradient(circle at top right, #ffafcc, #bde0fe);
        }

        .bg-level-4 {
            background-image: radial-gradient(circle at top right, #ff9eb1, #a2d2ff);
        }

        .bg-level-5 {
            background-image: radial-gradient(circle at top right, #ff8fa3, #9381ff);
        }

        .bg-level-6 {
            background-image: radial-gradient(circle at top right, #ff758c, #8479e1);
        }

        .bg-level-7 {
            background-image: radial-gradient(circle at top right, #ff5d8f, #725ac1);
        }

        .bg-level-8 {
            background-image: radial-gradient(circle at top right, #ff4d6d, #5d3fd3);
        }

        .game-container {
            background-color: #fff0f3;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
            max-width: 400px;
            width: 100%;
            margin: 0 auto;
            backdrop-filter: blur(10px);
            background-color: rgba(255, 240, 243, 0.8);
            position: relative;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .title {
            font-size: 24px;
            font-weight: bold;
            color: #ff4f77;
            background: linear-gradient(90deg, #ff4f77, #a37eff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .score-container {
            display: flex;
            gap: 10px;
        }

        .score-box {
            background-color: rgba(255, 194, 209, 0.7);
            padding: 8px 16px;
            border-radius: 8px;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .score-label {
            font-size: 12px;
            color: #885a64;
        }

        .score-value {
            font-size: 18px;
            font-weight: bold;
            color: #5a427d;
        }

        .buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            background: linear-gradient(135deg, #ff4f77, #ff758c);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            box-shadow: 0 4px 6px rgba(255, 79, 119, 0.2);
        }

        button:hover {
            background: linear-gradient(135deg, #ff758c, #ff4f77);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(255, 79, 119, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            background-color: #ffc2d1;
            padding: 10px;
            border-radius: 10px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            position: relative;
            height: 400px; /* å›ºå®šé«˜åº¦ */
            border: 3px solid #ff94a9; /* å¢å¼ºç½‘æ ¼è¾¹æ¡† */
        }

        .tile {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px; /* è°ƒå¤§æ•°å­—å­—å· */
            font-weight: bold;
            transition: all 0.2s ease-out;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 0 0 2px rgba(255, 255, 255, 0.3); /* å¢åŠ ç«‹ä½“æ„Ÿ */
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 1;
            transform: scale(0.95);
            will-change: transform, left, top;
            background-image: url('https://www.transparenttextures.com/patterns/brick-wall.png'); /* æ·»åŠ çº¹ç† */
        }

        .tile-2 {
            background-color: #ffd6e0;
            color: #885a64;
        }

        .tile-4 {
            background-color: #ffc2d1;
            color: #7a4d56;
        }

        .tile-8 {
            background-color: #ffb3c6;
            color: #6b414a;
        }

        .tile-16 {
            background-color: #ff94a9;
            color: white;
        }

        .tile-32 {
            background-color: #ff859b;
            color: white;
        }

        .tile-64 {
            background-color: #ff758c;
            color: white;
        }

        .tile-128 {
            background-color: #ffc8dd;
            color: #805d6a;
            font-size: 30px; /* è°ƒå¤§æ•°å­—å­—å· */
        }

        .tile-256 {
            background-color: #ffafcc;
            color: #735360;
            font-size: 30px; /* è°ƒå¤§æ•°å­—å­—å· */
        }

        .tile-512 {
            background-color: #ff9eb1;
            color: white;
            font-size: 28px; /* è°ƒå¤§æ•°å­—å­—å· */
        }

        .tile-1024 {
            background-color: #bde0fe;
            color: #4a6fa5;
            font-size: 26px; /* è°ƒå¤§æ•°å­—å­—å· */
        }

        .tile-2048 {
            background-color: #a2d2ff;
            color: #39567d;
            font-size: 26px; /* è°ƒå¤§æ•°å­—å­—å· */
        }

        .tile-4096 {
            background-color: #c8b6ff;
            color: #5a427d;
            font-size: 24px; /* è°ƒå¤§æ•°å­—å­—å· */
        }

        .tile-8192 {
            background-color: #bdb2ff;
            color: #4a3566;
            font-size: 24px; /* è°ƒå¤§æ•°å­—å­—å· */
        }

        .tile-16384 {
            background-color: #a2d2ff;
            color: #39567d;
            font-size: 22px; /* è°ƒå¤§æ•°å­—å­—å· */
        }

        .tile-32768 {
            background-color: #9381ff;
            color: white;
            font-size: 22px; /* è°ƒå¤§æ•°å­—å­—å· */
        }

        .tile-65536 {
            background-color: #8479e1;
            color: white;
            font-size: 20px; /* è°ƒå¤§æ•°å­—å­—å· */
        }

        .tile-131072 {
            background-color: #725ac1;
            color: white;
            font-size: 18px; /* è°ƒå¤§æ•°å­—å­—å· */
        }

        .tile-move {
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), 
                        left 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), 
                        top 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .tile-merge {
            animation: merge 0.4s ease-out forwards;
            z-index: 20;
        }

        @keyframes merge {
            0% { transform: scale(0.95); }
            50% { transform: scale(1.2); }
            100% { transform: scale(0.95); }
        }

        .tile-new {
            animation: pop 0.4s ease-out;
        }

        @keyframes pop {
            0% { transform: scale(0.7); opacity: 0.7; }
            70% { transform: scale(1.05); }
            100% { transform: scale(0.95); opacity: 1; }
        }

        .tile-first-appear {
            animation: firstAppear 0.8s ease-in-out;
        }

        @keyframes firstAppear {
            0%, 100% { transform: scale(0.95); }
            25% { transform: scale(1.15) rotate(-7deg); }
            50% { transform: scale(1.2) rotate(7deg); }
            75% { transform: scale(1.1) rotate(-4deg); }
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: linear-gradient(135deg, #fff0f3, #ffe5ec);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-width: 300px;
            width: 100%;
            text-align: center;
            transform: scale(0.8);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .overlay.active .modal {
            transform: scale(1);
        }

        .modal-title {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #ff4f77, #a37eff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .modal-message {
            margin-bottom: 20px;
            color: #5a427d;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
        }

        .modal-buttons button {
            background: linear-gradient(135deg, #ff4f77, #ff758c);
        }

        .modal-buttons button:hover {
            background: linear-gradient(135deg, #ff758c, #ff4f77);
        }

        .revive-btn {
            background: linear-gradient(135deg, #a37eff, #bdb2ff) !important;
        }

        .revive-btn:hover {
            background: linear-gradient(135deg, #bdb2ff, #a37eff) !important;
        }

        .danmaku {
            position: absolute;
            top: 20%;
            left: -200px;
            background: linear-gradient(90deg, rgba(255, 79, 119, 0.8), rgba(163, 126, 255, 0.8));
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 20px;
            font-weight: bold;
            white-space: nowrap;
            z-index: 20;
            animation: danmaku 5s linear forwards;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        @keyframes danmaku {
            0% { left: -200px; }
            100% { left: calc(100% + 200px); }
        }

        .sound-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 30px;
            height: 30px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            backdrop-filter: blur(5px);
            z-index: 10;
            transition: all 0.2s ease;
        }

        .sound-toggle:hover {
            transform: scale(1.1);
            background-color: rgba(255, 255, 255, 0.9);
        }

        .sound-on::before {
            content: 'ğŸ”Š';
        }

        .sound-off::before {
            content: 'ğŸ”‡';
        }

        .particles-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .particle {
            position: absolute;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            opacity: 0.8;
            animation: particleAnimation 1s ease-out forwards;
        }

        @keyframes particleAnimation {
            0% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(3); opacity: 0; }
        }
    </style>
</head>

<body class="bg-level-1">
    <div class="game-container">
        <div class="header">
            <div class="title">2048 - æµç•…ç‰ˆ</div>
            <div class="score-container">
                <div class="score-box">
                    <div class="score-label">å½“å‰åˆ†æ•°</div>
                    <div class="score-value" id="current-score">0</div>
                </div>
                <div class="score-box">
                    <div class="score-label">å†å²æœ€é«˜</div>
                    <div class="score-value" id="best-score">0</div>
                </div>
            </div>
        </div>

        <div class="buttons">
            <button id="restart-btn">é‡æ–°å¼€å§‹</button>
        </div>

        <div class="grid" id="grid"></div>

        <div id="sound-toggle" class="sound-toggle sound-on"></div>
    </div>

    <div class="overlay" id="game-over-modal">
        <div class="modal">
            <div class="modal-title">æ¸¸æˆç»“æŸ!</div>
            <div class="modal-message">
                ä½ çš„åˆ†æ•°: <span id="final-score">0</span><br>
                <span id="revive-text">ä½ å¯ä»¥å¤æ´»ä¸€æ¬¡</span>
            </div>
            <div class="modal-buttons">
                <button id="revive-btn" class="revive-btn">å¤æ´»</button>
                <button id="restart-modal-btn">é‡æ–°å¼€å§‹</button>
            </div>
        </div>
    </div>

    <audio id="move-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-small-hit-in-a-game-2072.mp3" type="audio/mpeg">
    </audio>
    <audio id="merge-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3" type="audio/mpeg">
    </audio>
    <audio id="record-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" type="audio/mpeg">
    </audio>
    <audio id="gameover-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-player-losing-or-failing-2042.mp3" type="audio/mpeg">
    </audio>
    <audio id="revive-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-magic-spell-swoosh-2297.mp3" type="audio/mpeg">
    </audio>
    <audio id="clear-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3" type="audio/mpeg">
    </audio>

    <script>
        // æ¸¸æˆçŠ¶æ€å˜é‡
        let board = Array(4).fill().map(() => Array(4).fill(0));
        let score = 0;
        let targetScore = 0;
        let scoreAnimationId = null;
        const scoreAnimationDuration = 1000; // åˆ†æ•°åŠ¨ç”»æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        const scoreSteps = 30; // åˆ†æ•°åŠ¨ç”»æ­¥æ•°
        let bestScore = localStorage.getItem('bestScore') || 0;
        let canRevive = true;
        let lastState = null;
        let isMoving = false;
        let isMusicEnabled = true;

        let appearedNumbers = new Set();

        // DOM å…ƒç´ 
        const gridEl = document.getElementById('grid');
        const currentScoreEl = document.getElementById('current-score');
        const bestScoreEl = document.getElementById('best-score');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScoreEl = document.getElementById('final-score');
        const reviveText = document.getElementById('revive-text');
        const soundToggle = document.getElementById('sound-toggle');
        const body = document.body;

        // éŸ³æ•ˆå…ƒç´ 
        const moveSound = document.getElementById('move-sound');
        const mergeSound = document.getElementById('merge-sound');
        const recordSound = document.getElementById('record-sound');
        const gameoverSound = document.getElementById('gameover-sound');
        const reviveSound = document.getElementById('revive-sound');
        const clearSound = document.getElementById('clear-sound');

        // æ¸¸æˆéš¾åº¦å’ŒçŠ¶æ€è·Ÿè¸ª
        let lastScoreMilestone = 0;
        let emptyCellCount = 0;
        let criticalSurvivalCount = 0;

        bestScoreEl.textContent = bestScore;

        // å£°éŸ³æ§åˆ¶
        soundToggle.addEventListener('click', () => {
            isMusicEnabled = !isMusicEnabled;
            soundToggle.className = isMusicEnabled ? 'sound-toggle sound-on' : 'sound-toggle sound-off';
        });

        function playSound(sound) {
            if (isMusicEnabled) {
                sound.currentTime = 0;
                sound.play().catch(e => console.log('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', e));
            }
        }

        // æ›´æ–°åˆ†æ•°æ˜¾ç¤ºï¼Œå¸¦å¹³æ»‘åŠ¨ç”»æ•ˆæœ
        function updateScores() {
            // å¦‚æœç›®æ ‡åˆ†æ•°å’Œå½“å‰åˆ†æ•°ä¸åŒï¼Œåˆ™å¯åŠ¨åŠ¨ç”»
            if (targetScore !== score) {
                cancelAnimationFrame(scoreAnimationId);
                
                const startScore = score;
                const scoreDiff = targetScore - startScore;
                let step = 0;
                
                const animateScore = () => {
                    step++;
                    if (step <= scoreSteps) {
                        // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°ä½¿åŠ¨ç”»æ›´è‡ªç„¶
                        const progress = easeOutCubic(step / scoreSteps);
                        score = Math.floor(startScore + scoreDiff * progress);
                        currentScoreEl.textContent = score;
                        scoreAnimationId = requestAnimationFrame(animateScore);
                    } else {
                        // ç¡®ä¿æœ€ç»ˆå€¼å‡†ç¡®
                        score = targetScore;
                        currentScoreEl.textContent = score;
                    }
                };
                
                animateScore();
            }
            
            // æ›´æ–°æœ€é«˜åˆ†
            if (targetScore > bestScore) {
                bestScore = targetScore;
                bestScoreEl.textContent = bestScore;
                localStorage.setItem('bestScore', bestScore);
                
                // æ–°çºªå½•ç‰¹æ•ˆ
                bestScoreEl.classList.add('new-record');
                setTimeout(() => {
                    bestScoreEl.classList.remove('new-record');
                }, 1000);
                
                // æ’­æ”¾æ–°çºªå½•éŸ³æ•ˆ
                playSound(recordSound);
            }
        }

        // ç¼“åŠ¨å‡½æ•°ï¼šä¸‰æ¬¡æ–¹ç¼“å‡º
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        // å¢åŠ åˆ†æ•°ï¼ˆå¸¦å¢é‡åŠ¨ç”»ï¼‰
        function addScore(points) {
            targetScore += points;
            updateScores();
            
            // æ˜¾ç¤ºåˆ†æ•°å¢åŠ çš„åŠ¨ç”»æ•ˆæœ
            showScorePopup(points);
        }

        // æ˜¾ç¤ºåˆ†æ•°å¢åŠ çš„å¼¹å‡ºåŠ¨ç”»
        function showScorePopup(points) {
            const scorePopup = document.createElement('div');
            scorePopup.className = 'score-popup';
            scorePopup.textContent = '+' + points;
            
            // å®šä½åˆ°åˆ†æ•°æ˜¾ç¤ºä¸Šæ–¹
            const scoreBox = currentScoreEl.parentElement;
            const rect = scoreBox.getBoundingClientRect();
            const gridRect = gridEl.getBoundingClientRect();
            
            scorePopup.style.left = `${rect.left - gridRect.left + rect.width/2}px`;
            scorePopup.style.top = `${rect.top - gridRect.top - 30}px`;
            
            gridEl.appendChild(scorePopup);
            
            // æ‰§è¡ŒåŠ¨ç”»
            setTimeout(() => {
                scorePopup.style.opacity = '0';
                scorePopup.style.transform = 'translateY(-20px)';
                
                setTimeout(() => {
                    gridEl.removeChild(scorePopup);
                }, 500);
            }, 10);
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        function init() {
            // é‡ç½®åˆ†æ•°
            score = 0;
            targetScore = 0;
            currentScoreEl.textContent = score;
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            board = Array(4).fill().map(() => Array(4).fill(0));
            canRevive = true;
            lastState = null;
            appearedNumbers = new Set([2, 4]);
            lastScoreMilestone = 0;
            emptyCellCount = 0;
            criticalSurvivalCount = 0;
            updateBackgroundColor();
            addTile();
            addTile();
            render();
        }

        // æ·»åŠ æ–°æ–¹å—
        function addTile() {
            const emptyCells = [];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (board[i][j] === 0) emptyCells.push([i, j]);
                }
            }

            emptyCellCount = emptyCells.length;

            if (emptyCells.length > 0) {
                const [x, y] = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                board[x][y] = Math.random() < 0.9 ? 2 : 4;

                setTimeout(() => {
                    render();
                    const tiles = gridEl.querySelectorAll('.tile');
                    const index = x * 4 + y;
                    if (tiles[index]) {
                        tiles[index].classList.add('tile-new');
                    }

                    checkCriticalSurvival();
                }, 100);
            }
        }

        // æ¸²æŸ“æ¸¸æˆç•Œé¢
        function render() {
            // æ¸…ç©ºç½‘æ ¼
            gridEl.innerHTML = '';
            
            // è·å–ç½‘æ ¼å°ºå¯¸
            const gridRect = gridEl.getBoundingClientRect();
            const cellSize = (gridRect.width - 30) / 4; // å‡å»é—´éš™
            
            // åˆ›å»ºæ‰€æœ‰æ–¹å—
            board.forEach((row, rowIndex) => {
                row.forEach((val, colIndex) => {
                    if (val !== 0) {
                        const tile = document.createElement('div');
                        const tileClass = val ? `tile-${val}` : '';
                        tile.className = `tile ${tileClass}`;
                        tile.textContent = val || '';
                        
                        // è®¾ç½®ä½ç½®å’Œå¤§å°
                        tile.style.left = `${colIndex * (cellSize + 10)}px`;
                        tile.style.top = `${rowIndex * (cellSize + 10)}px`;
                        tile.style.width = `${cellSize}px`;
                        tile.style.height = `${cellSize}px`;
                        
                        // è®°å½•åŸå§‹ä½ç½®
                        tile.dataset.row = rowIndex;
                        tile.dataset.col = colIndex;
                        
                        // é¦–æ¬¡å‡ºç°çš„æ•°å­—ç‰¹æ®ŠåŠ¨ç”»
                        if (recentlyAppearedNumbers.has(val)) {
                            tile.classList.add('tile-first-appear');
                        }
                        
                        gridEl.appendChild(tile);
                    }
                });
            });
            
            updateScores();
        }

        let recentlyAppearedNumbers = new Set();

        // ç§»åŠ¨æ–¹å—
        function move(direction) {
            if (isMoving || isGameOver()) return;
            isMoving = true;
            recentlyAppearedNumbers.clear();

            const prevBoard = JSON.parse(JSON.stringify(board));
            let moved = false;
            let mergedPositions = new Set();
            let hasMerge = false;

            function merge(line) {
                let newLine = line.filter(n => n !== 0);
                for (let i = 0; i < newLine.length - 1; i++) {
                    if (newLine[i] === newLine[i + 1] && !mergedPositions.has(i)) {
                        const mergedValue = newLine[i] * 2;
                        newLine[i] = mergedValue;
                        newLine.splice(i + 1, 1);
                        mergedPositions.add(i);
                        moved = true;
                        hasMerge = true;

                        // å¢åŠ åˆ†æ•°
                        addScore(mergedValue);

                        if (!appearedNumbers.has(mergedValue)) {
                            appearedNumbers.add(mergedValue);
                            recentlyAppearedNumbers.add(mergedValue);
                        }
                    }
                }
                while (newLine.length < 4) newLine.push(0);
                return newLine;
            }

            switch (direction) {
                case 'left':
                    board = board.map(row => merge(row));
                    break;
                case 'right':
                    board = board.map(row => merge(row.reverse()).reverse());
                    break;
                case 'up':
                    const transposedUp = transpose(board);
                    board = transpose(transposedUp.map(col => merge(col)));
                    break;
                case 'down':
                    const transposedDown = transpose(board);
                    board = transpose(transposedDown.map(col => merge(col.reverse()).reverse()));
                    break;
            }

            if (JSON.stringify(board) !== JSON.stringify(prevBoard)) {
                lastState = {
                    board: JSON.parse(JSON.stringify(prevBoard)),
                    score: score
                };

                // æ ¹æ®æ˜¯å¦æœ‰æ•°å­—èåˆæ’­æ”¾ä¸åŒéŸ³æ•ˆ
                playSound(hasMerge ? mergeSound : moveSound);

                animateMove(prevBoard, () => {
                    addTile();
                    render();
                    isMoving = false;

                    checkScoreMilestones();

                    if (score > bestScore) {
                        showDanmaku("å®å®å¤ªç‰›äº†ï¼");
                    }

                    if (recentlyAppearedNumbers.size > 0) {
                        recentlyAppearedNumbers.forEach(num => {
                            showDanmaku(`é¦–æ¬¡åˆæˆ ${num}ï¼`);
                        });
                    }

                    if (isGameOver()) {
                        playSound(gameoverSound);
                        showGameOver();
                    }
                });

                if (hasMerge) {
                    createParticlesForMerges(prevBoard);
                }
            } else {
                isMoving = false;
            }
        }

        // è½¬ç½®çŸ©é˜µ
        function transpose(matrix) {
            return matrix[0].map((_, col) => matrix.map(row => row[col]));
        }

        // åŠ¨ç”»ç§»åŠ¨æ•ˆæœ
        function animateMove(prevBoard, callback) {
            const tiles = gridEl.querySelectorAll('.tile');
            const gridRect = gridEl.getBoundingClientRect();
            const cellSize = (gridRect.width - 30) / 4; // å‡å»é—´éš™
            const animations = [];
            
            // æ¸…ç©ºç°æœ‰åŠ¨ç”»ç±»
            tiles.forEach(tile => {
                tile.classList.remove('tile-move', 'tile-merge');
            });
            
            // æ”¶é›†æ‰€æœ‰éœ€è¦ç§»åŠ¨å’Œåˆå¹¶çš„æ–¹å—
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const prevValue = prevBoard[i][j];
                    const currentValue = board[i][j];
                    
                    if (prevValue !== 0) {
                        // æ‰¾åˆ°è¿™ä¸ªæ–¹å—åœ¨æ–°çŠ¶æ€ä¸­çš„ä½ç½®
                        let targetRow = i;
                        let targetCol = j;
                        let isMerge = false;
                        
                        // ç¡®å®šç›®æ ‡ä½ç½®å’Œæ˜¯å¦åˆå¹¶
                        if (direction === 'left') {
                            // å‘å·¦ç§»åŠ¨ï¼Œæ‰¾åˆ°æœ€å·¦å¯åˆ°è¾¾ä½ç½®
                            targetCol = j;
                            while (targetCol > 0 && prevBoard[i][targetCol - 1] === 0) {
                                targetCol--;
                            }
                            // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆå¹¶
                            if (targetCol > 0 && prevBoard[i][targetCol - 1] === prevValue) {
                                targetCol--;
                                isMerge = true;
                            }
                        } else if (direction === 'right') {
                            // å‘å³ç§»åŠ¨ï¼Œæ‰¾åˆ°æœ€å³å¯åˆ°è¾¾ä½ç½®
                            targetCol = j;
                            while (targetCol < 3 && prevBoard[i][targetCol + 1] === 0) {
                                targetCol++;
                            }
                            // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆå¹¶
                            if (targetCol < 3 && prevBoard[i][targetCol + 1] === prevValue) {
                                targetCol++;
                                isMerge = true;
                            }
                        } else if (direction === 'up') {
                            // å‘ä¸Šç§»åŠ¨ï¼Œæ‰¾åˆ°æœ€ä¸Šå¯åˆ°è¾¾ä½ç½®
                            targetRow = i;
                            while (targetRow > 0 && prevBoard[targetRow - 1][j] === 0) {
                                targetRow--;
                            }
                            // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆå¹¶
                            if (targetRow > 0 && prevBoard[targetRow - 1][j] === prevValue) {
                                targetRow--;
                                isMerge = true;
                            }
                        } else if (direction === 'down') {
                            // å‘ä¸‹ç§»åŠ¨ï¼Œæ‰¾åˆ°æœ€ä¸‹å¯åˆ°è¾¾ä½ç½®
                            targetRow = i;
                            while (targetRow < 3 && prevBoard[targetRow + 1][j] === 0) {
                                targetRow++;
                            }
                            // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆå¹¶
                            if (targetRow < 3 && prevBoard[targetRow + 1][j] === prevValue) {
                                targetRow++;
                                isMerge = true;
                            }
                        }
                        
                        // æ‰¾åˆ°å¯¹åº”çš„DOMå…ƒç´ 
                        const tile = gridEl.querySelector(`.tile[data-row="${i}"][data-col="${j}"]`);
                        if (tile) {
                            animations.push({
                                tile,
                                from: { row: i, col: j },
                                to: { row: targetRow, col: targetCol },
                                isMerge
                            });
                        }
                    }
                }
            }
            
            // æ‰§è¡Œæ‰€æœ‰ç§»åŠ¨åŠ¨ç”»
            animations.forEach(({ tile, from, to, isMerge }) => {
                // è®¾ç½®åˆå§‹ä½ç½®
                tile.style.left = `${from.col * (cellSize + 10)}px`;
                tile.style.top = `${from.row * (cellSize + 10)}px`;
                
                // æ·»åŠ ç§»åŠ¨ç±»
                tile.classList.add('tile-move');
                
                // ä½¿ç”¨requestAnimationFrameç¡®ä¿æ ·å¼å·²åº”ç”¨
                requestAnimationFrame(() => {
                    // è®¾ç½®ç›®æ ‡ä½ç½®
                    tile.style.left = `${to.col * (cellSize + 10)}px`;
                    tile.style.top = `${to.row * (cellSize + 10)}px`;
                    
                    // å¦‚æœæ˜¯åˆå¹¶ï¼Œæ·»åŠ åˆå¹¶åŠ¨ç”»
                    if (isMerge) {
                        setTimeout(() => {
                            tile.classList.add('tile-merge');
                        }, 150);
                    }
                });
            });
            
            // ç­‰å¾…æ‰€æœ‰åŠ¨ç”»å®Œæˆåæ‰§è¡Œå›è°ƒ
            setTimeout(callback, 350);
        }

        // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
        function isGameOver() {
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (board[i][j] === 0) return false;
                }
            }

            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const current = board[i][j];
                    if (j < 3 && board[i][j + 1] === current) return false;
                    if (i < 3 && board[i + 1][j] === current) return false;
                }
            }

            return true;
        }

        // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
        function showGameOver() {
            finalScoreEl.textContent = score;

            if (canRevive) {
                reviveText.textContent = "ä½ å¯ä»¥å¤æ´»ä¸€æ¬¡";
                document.getElementById('revive-btn').style.display = 'block';
            } else {
                reviveText.textContent = "ä½ å·²ä½¿ç”¨è¿‡å¤æ´»æœºä¼š";
                document.getElementById('revive-btn').style.display = 'none';
            }

            gameOverModal.classList.add('active');
        }

        // å¤æ´»åŠŸèƒ½
        function revive() {
            if (canRevive) {
                canRevive = false;
                gameOverModal.classList.remove('active');

                const clearPositions = [];
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        if (board[i][j] <= 8) {
                            clearPositions.push({ row: i, col: j });
                            board[i][j] = 0;
                        }
                    }
                }

                playSound(reviveSound);

                render();
                const tiles = gridEl.querySelectorAll('.tile');
                clearPositions.forEach(pos => {
                    const index = pos.row * 4 + pos.col;
                    if (tiles[index]) {
                        tiles[index].classList.add('tile-clear');
                    }
                });

                setTimeout(() => {
                    addTile();
                    render();

                    if (isGameOver()) {
                        playSound(gameoverSound);
                        showGameOver();
                    }
                }, 500);
            }
        }

        // æ˜¾ç¤ºå¼¹å¹•
        function showDanmaku(text) {
            const danmaku = document.createElement('div');
            danmaku.className = 'danmaku';
            danmaku.textContent = text;

            const topPos = 20 + Math.random() * 30;
            danmaku.style.top = `${topPos}%`;

            document.body.appendChild(danmaku);

            setTimeout(() => {
                danmaku.remove();
            }, 5000);
        }

        // æ›´æ–°èƒŒæ™¯é¢œè‰²
        function updateBackgroundColor() {
            const level = Math.min(8, Math.floor(score / 1000) + 1);
            body.className = `bg-level-${level}`;
        }

        // æ£€æŸ¥åˆ†æ•°é‡Œç¨‹ç¢‘
        function checkScoreMilestones() {
            const currentMilestone = Math.floor(score / 1000);
            if (currentMilestone > lastScoreMilestone) {
                showDanmaku(`è¾¾æˆ ${currentMilestone * 1000} åˆ†ï¼`);
                lastScoreMilestone = currentMilestone;
            }
            updateBackgroundColor();
        }

        // æ£€æŸ¥ä¸´ç•Œç”Ÿå­˜çŠ¶æ€
        function checkCriticalSurvival() {
            if (emptyCellCount === 1) {
                criticalSurvivalCount++;

                if (criticalSurvivalCount === 5) {
                    showDanmaku("ç»åœ°é€¢ç”Ÿï¼Œå‰å®³å•Šï¼");
                    criticalSurvivalCount = 0;
                }
            } else {
                criticalSurvivalCount = 0;
            }
        }

        // åˆ›å»ºåˆå¹¶ç‰¹æ•ˆç²’å­
        function createParticlesContainer() {
            let container = document.querySelector('.particles-container');
            if (!container) {
                container = document.createElement('div');
                container.className = 'particles-container';
                gridEl.appendChild(container);
            }
            return container;
        }

        function createParticlesForMerges(prevBoard) {
            const container = createParticlesContainer();

            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (prevBoard[i][j] !== 0 && board[i][j] > prevBoard[i][j]) {
                        const tile = gridEl.querySelector(`.tile[data-row="${i}"][data-col="${j}"]`);
                        if (tile) {
                            const { top, left, width, height } = tile.getBoundingClientRect();
                            const gridRect = gridEl.getBoundingClientRect();
                            const centerX = left + width / 2 - gridRect.left;
                            const centerY = top + height / 2 - gridRect.top;
                            const tileColor = getComputedStyle(tile).backgroundColor;

                            for (let k = 0; k < 15; k++) {
                                const particle = document.createElement('div');
                                particle.className = 'particle';

                                const angle = Math.random() * 2 * Math.PI;
                                const distance = (0.3 + Math.random() * 0.5) * Math.min(width, height) / 2;

                                const targetX = centerX + distance * Math.cos(angle);
                                const targetY = centerY + distance * Math.sin(angle);

                                particle.style.left = `${centerX}px`;
                                particle.style.top = `${centerY}px`;
                                particle.style.backgroundColor = tileColor;

                                container.appendChild(particle);

                                requestAnimationFrame(() => {
                                    particle.style.left = `${targetX}px`;
                                    particle.style.top = `${targetY}px`;

                                    setTimeout(() => {
                                        if (container.contains(particle)) {
                                            container.removeChild(particle);
                                        }
                                    }, 1000);
                                });
                            }
                        }
                    }
                }
            }
        }

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            const keyMap = {
                37: 'left', 38: 'up', 39: 'right', 40: 'down'
            };
            if (keyMap[e.keyCode]) {
                direction = keyMap[e.keyCode];
                move(direction);
            }
        });

        // è§¦æ‘¸æ§åˆ¶
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        document.addEventListener('touchend', (e) => {
            if (!touchStartX) return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            if (Math.abs(dx) > 30 || Math.abs(dy) > 30) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    direction = dx > 0 ? 'right' : 'left';
                    move(direction);
                } else {
                    direction = dy > 0 ? 'down' : 'up';
                    move(direction);
                }
            }

            touchStartX = 0;
            touchStartY = 0;
        }, { passive: true });

        // æŒ‰é’®äº‹ä»¶
        document.getElementById('restart-btn').addEventListener('click', init);
        document.getElementById('restart-modal-btn').addEventListener('click', () => {
            gameOverModal.classList.remove('active');
            init();
        });
        document.getElementById('revive-btn').addEventListener('click', revive);

        // åˆå§‹åŒ–æ¸¸æˆ
        let direction = '';
        init();
    </script>
</body>

</html>    